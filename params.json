{"name":"Comparte Mesas AVE","tagline":"App para Android que permite establecer comunicación entre varios usuarios que quieran compartir una mesa en el AVE.","body":"# Comparte Mesa\r\n\r\n## Motivación\r\n\r\nActualmente RENFE ofrece una tarifa que resulta muy económica a la hora de viajar en AVE. Esta tarifa permite comprar un billete de una mesa en las que pueden ir cuatro personas en lugar de forma individual. El precio por persona es del 60% comparado con el billete individuale estándar.\r\n\r\nPara usar esta tarifa y que resulte económica es necesario ser cuatro personas, aquí es donde entra en juego nuestra aplicación. Usando esta app se puede encontrar los compañeros que falten y así poder comprar billete para mesa, ahorrando dinero.\r\n\r\nLa aplicación tratará de emparejar al usuario formando grupos de cuatro, una vez formado el grupo establecerá un chat que permitirá la comunicación para poder ponerse de acuerdo y comprar el billete.\r\n\r\n## Resumen\r\n\r\nLa Aplicación, a rasgos generales, lo que hace es dar al usuario la posibilidad de encontrar, si existiera, un grupo de tres personas más que compartan el origen, el destino y el horario de su viaje para así poder aprovechar de la tarifa de mesa.\r\n\r\n### Estado de la aplicación\r\n\r\nLa aplicación se encuentra en fase beta. Por ahora las funcionalidades disponibles son:\r\n\r\n- Crear mesa seleccionando origen, destino y tiempo de salida del tren.\r\n- Listar las mesas creadas por otros usarios y unirse a una de ellas.\r\n- Eliminar y salirse de las mesas.\r\n- Configurar un nombre de usuario.\r\n- Servidor AXIS2 para servir los datos de las mesas a los clientes.\r\n- Clientes con librerías KSOAP2 para consumir el servicio web proporcionado por AXIS2.\r\n\r\nFuncionalidades a implementar en el futuro:\r\n\r\n- Migrar el servidor a Node.JS.\r\n- Usar GCM para notificaciones PUSH.\r\n- Servidor XMPP para el chat multiusuario.\r\n- Login mediante cuenta de Google+, Facebook o Twitter.\r\n- Compartir enlace a mesas por redes sociales.\r\n- Perfiles de usuario con valoraciones.\r\n- Opción de aumentar la visibilidad de una mesa mediante micropagos.\r\n\r\n## Estructura de la aplicación\r\n\r\nAhora pasamos a describir como hemos desarrollado la aplicación explicando los aspectos más destacados de el código de la misma.\r\n\r\n### Packet: data\r\n\r\nAquí se encuentran todos objetos que almacenan información. Tenemos los siguientes:\r\n\r\n- `Cities.java`: Se usa para mapear enteros a ciudades. Cada entero representa una ciudad y este objeto se encarga de convertir cada entero a su correspondiente String. En el futuro será capaz de conocer a qué ciudad destino se puede llegar desde qué ciudad origen. Por ahora simplemente está implementando el mapeo.\r\n- `User.java`: Almacena información de usuarios. Por ejemplo el nombre, el email o la contraseña. Por ahora sólo está implementado el nombre. Además tiene un campo que es un ID único por cada usuario.\r\n- `Table.java`: Representa una mesa. Tiene un ID único, un origen, un destino, una hora de salida y una lista de hasta cuatro usuario. El primero usuario es el que la creó y el único que puede borrarla, los demás usuario sólo pueden abandonarla.\r\n\r\n### Packet: tables\r\n\r\nEste paquete contiene lo referente a las mesas.\r\n\r\n- `TableFragment.java`: Es el fragmento que muesetra toda la información de la mesa a la que estamos asociado. Si no hay ninguna mesa a la que estemos asociado, nos mostrará un botón para crear una mesa nueva. Entre las cosas que muestra nos encontramos el origen y el destino, la lista de los usuarios que están unidos actualmente a la mesa y un chat para la comunicación (acualmente no implementado).\r\n- `AddTableActivity.java`: Actividad encargada de mostrar la interfaz para crear una nueva mesa. Nos permite elegir el origen, el destino y una hora de salida.\r\n\r\n### Packet: search\r\n\r\n- `SearchFragment`: Este framento nos muestra las mesas que han sido creadas en el servidor. Se muestra el origen y el destino y podemos unirnos a la que más nos convenga. En el futuro implementará un filtro por origen y destino. También podría ser interesante que hubiese algunas mesas \"patrocinadas\" que apareciesen en posiciones más altas si el usuario ha efectuado un pago.\r\n\r\n### Packet: interfaces\r\n\r\nEste paquete contine interfaces usadas por nuestro programa.\r\n\r\n- `TableOperationCallback`: Esta interfaz se usa para funciones de callbacks en tareas asíncronas que realizan conexiones contra el servidor.\r\n\r\n### Packet communication\r\n\r\nEste paquete contiene objetos que heredan de la clase `AsyncTask`, que ejecutan una tarea en un hilo independiente y, al finalizar ejecutan un método. Hemos aprovechado este método para llamar a una función de callback usando la interfaz `TableOperationCallback`. De esta nuestro programa funciona de forma totalmente asíncrona sin tiempos de espera en el hilo de la interfaz gráfica. El propósito de todas estos objetos es la comunicación con el servidor por medio de KSOAP2.\r\n\r\n- `ChangeNameTask`: Se usa para cambiar el nombre de usuario.\r\n- `CreateTableTask`: Crea una mesa en el servidor.\r\n- `CreateUserTask`: Crea un usuario en el servidor.\r\n- `JoinTableTask`: Se usa para unirse a una mesa ya existente en el servidor.\r\n- `LoadMyTableTask`: Se usa para preguntar al servidor si estamos en alguna mesa y, en caso afirmativo, descargarnos los datos de tal mesa.\r\n- `LoadTablesTask`: Descarga una lista de las mesas que se encuentran en el servidor.\r\n- `RemoveMyTableTask`: Dejamos una mesa a la que pertenecemos. En caso de ser el dueño de esta mesa el servidor la eliminará.\r\n\r\n### ComparteMesaApplication.java\r\n\r\nEs un objeto de clase aplicación. Su cometido es ofrecer \"variables globales\" y métodos estáticos para almacenar objetos a los que necesitaremos acceder desde diferentes partes de la aplicación.\r\n\r\n### ConfigActivity.java\r\n\r\nEs una actividad que simplemente nos permite cambiar nuestro nombre de usuario por ahora.\r\n\r\n### MainActivity.java\r\n\r\nEs la actividad principal de la aplicación y la más importante. vamos a detallar sus métodos.\r\n\r\n#### OnCreate()\r\n\r\nSe carga el layout en pantalla. Después se cargan las preferencias y se llama a la función `init()` que inicia la interfaz de la aplicación.\r\n\r\n```java\r\npublic void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        supportRequestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\r\n        setContentView(R.layout.activity_main);\r\n\r\n        // Cargo las preferencias\r\n        loadPrefs();\r\n\r\n        // Inicializo el NavigationDrawer y la ActionBar\r\n        init();\r\n\r\n    }\r\n```\r\n\r\n### loadPrefs()\r\n\r\nUsamos un objejto `SharedPreferences` para almacenar nuestro ID de usuario. Si no tenemos ninguno le pedirmemos al servidor que nos de de alta y nos proporciene uno.\r\n\r\nPuede verse como hemos usado una función de callback con una tarea asíncrona para comunicarnos con el servidor. Usamos la misma filosofía durante toda la aplicación.\r\n\r\n```java\r\nprivate void loadPrefs() {\r\n        int mode = Activity.MODE_PRIVATE;\r\n        final SharedPreferences pref = getSharedPreferences(\"prefs\", mode);\r\n        String myUUID = pref.getString(\"myUUID\", \"null\");\r\n        String myName = pref.getString(\"myName\", \"Usuario\");\r\n\r\n        Log.d(\"PREFS\", \"Cargada UUID: \" + myUUID);\r\n\r\n        // Cargo el UUID almacenado, si no hay ninguno pido uno nuevo al servidor\r\n\r\n        if (myUUID.contentEquals(\"null\")) {\r\n            CreateUser createUser = new CreateUser(new TableOperationCallback() {\r\n                @Override\r\n                public void onTaskDone(Object... params) {\r\n                    String myName = pref.getString(\"myName\", \"User\");\r\n\r\n                    ChangeNameTask changeNameTask = new ChangeNameTask();\r\n                    changeNameTask.execute(myName);\r\n                }\r\n            });\r\n            createUser.execute(myName);\r\n        } else {\r\n            ComparteMesaApplication.setMyUUID(myUUID);\r\n            Log.d(\"MAIN\", \"Iniciada aplicación con UUID: \" + ComparteMesaApplication.getMyUUID());\r\n        }\r\n    }\r\n```\r\n\r\n#### DrawerNavigation\r\n\r\nHemos usado un DrawerNavigation por lo que necesitamos algunos métodos para iniciarlo correctamente:\r\n\r\n```java\r\n\t/**\r\n     * Función de callback para el NavigationDrawer y la ActionBar\r\n     */\r\n    @Override\r\n    protected void onPostCreate(Bundle savedInstanceState) {\r\n        super.onPostCreate(savedInstanceState);\r\n        drawerToggle.syncState();\r\n    }\r\n```\r\n\r\n```java\r\n    /**\r\n     * Función de callback para el NavigationDrawer y la ActionBar\r\n     */\r\n    @Override\r\n    public void onConfigurationChanged(Configuration newConfig) {\r\n        super.onConfigurationChanged(newConfig);\r\n        drawerToggle.onConfigurationChanged(newConfig);\r\n    }\r\n```\r\n\r\n```java\r\n    /**\r\n     * Inicializo el NavigatonDrawer y la ActionBar\r\n     */\r\n    private void init() {\r\n            final String[] opcionesMenu = getResources().getStringArray(R.array.navigation_drawer_elements);\r\n            final DrawerLayout drawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout);\r\n            final ListView drawerList = (ListView) findViewById(R.id.left_drawer);\r\n    \r\n            drawerList.setAdapter(new ArrayAdapter<String>(\r\n                    getSupportActionBar().getThemedContext(),\r\n                    android.R.layout.simple_list_item_1, opcionesMenu));\r\n    \r\n            drawerList.setOnItemClickListener(new AdapterView.OnItemClickListener() {\r\n                @Override\r\n                public void onItemClick(AdapterView parent, View view,\r\n                                        int position, long id) {\r\n    \r\n                    switch (position) {\r\n                        case 0:\r\n                            loadFragmentTable();\r\n                            break;\r\n                        case 1:\r\n                            loadSearch();\r\n                            break;\r\n                        case 2:\r\n                            configActivity();\r\n                            break;\r\n                    }\r\n    \r\n                    drawerList.setItemChecked(position, true);\r\n                    drawerLayout.closeDrawer(drawerList);\r\n                }\r\n    \r\n            });\r\n    \r\n            drawerToggle = new ActionBarDrawerToggle(this,\r\n                    drawerLayout,\r\n                    R.drawable.ic_navigation_drawer,\r\n                    R.string.drawer_open,\r\n                    R.string.drawer_close) {\r\n    \r\n                public void onDrawerClosed(View view) {\r\n                    getSupportActionBar().setTitle(tituloSeccion);\r\n                    ActivityCompat.invalidateOptionsMenu(MainActivity.this);\r\n                }\r\n    \r\n                public void onDrawerOpened(View drawerView) {\r\n                    getSupportActionBar().setTitle(getTitle());\r\n                    ActivityCompat.invalidateOptionsMenu(MainActivity.this);\r\n                }\r\n            };\r\n    \r\n            drawerLayout.setDrawerListener(drawerToggle);\r\n    \r\n            getSupportActionBar().setDisplayHomeAsUpEnabled(true);\r\n            getSupportActionBar().setHomeButtonEnabled(true);\r\n        }\r\n```\r\n\r\n```java\r\n    /**\r\n     * Función de callback para el NavigationDrawer y la ActionBar\r\n     */\r\n    @Override\r\n    public boolean onOptionsItemSelected(MenuItem item) {\r\n\r\n        if (drawerToggle.onOptionsItemSelected(item)) {\r\n            return true;\r\n        }\r\n\r\n        // Handle presses on the action bar items\r\n        Intent intent;\r\n        switch (item.getItemId()) {\r\n            case R.id.action_add:\r\n                intent = new Intent(this, AddTableActivity.class);\r\n                startActivity(intent);\r\n                return true;\r\n            case R.id.action_discard:\r\n                deleteTable();\r\n                onResume();\r\n                return true;\r\n            default:\r\n                return super.onOptionsItemSelected(item);\r\n        }\r\n    }\r\n```\r\n\r\n```java\r\n\t/**\r\n     * Función de callback para el botón añadir cuando no hay mesas\r\n     */\r\n    public void onClick(View view) {\r\n        if (view.getId() == R.id.create_table) {\r\n            Intent intent = new Intent(this, AddTableActivity.class);\r\n            startActivity(intent);\r\n        }\r\n    }\r\n```\r\n#### configActivity()\r\n\r\nAquí llamamos a la actividad `ConfigActivity`.\r\n\r\n```java\r\n\tpublic void configActivity() {\r\n        Intent intent = new Intent(this, ConfigActivity.class);\r\n        startActivity(intent);\r\n    }\r\n```\r\n\r\n#### loadSearch()\r\n\r\nCargamos las mesas en el servidor y llamamos al fragmento `SearchFragment` para que nos las muestre en una lista.\r\n\r\n```java\r\n    private void loadSearch() {\r\n\r\n        LoadTablesTask loadTables = new LoadTablesTask(new TableOperationCallback() {\r\n            @Override\r\n            public void onTaskDone(Object... loadedTables) {\r\n\r\n\r\n                tables = (List<Table>) loadedTables[0];\r\n\r\n                FragmentManager fragmentManager =\r\n                        getSupportFragmentManager();\r\n\r\n                fragmentManager.beginTransaction()\r\n                        .replace(R.id.content_frame, new SearchFragment())\r\n                        .commit();\r\n\r\n                tituloSeccion = \"Lista de mesas\";\r\n                getSupportActionBar().setTitle(tituloSeccion);\r\n                setSupportProgressBarIndeterminateVisibility(false);\r\n            }\r\n        });\r\n        setSupportProgressBarIndeterminateVisibility(true);\r\n        loadTables.execute();\r\n    }\r\n```\r\n\r\n#### loadFragmentTable()\r\n\r\nDescargamos del servidor los datos de la mesa a la que pertenecemos, en caso de pertenecer a alguna, y tras cargar los datos mostramos el fragmento para que nos los muestre.\r\n\r\n```java\r\n\t    private void loadFragmentTable() {\r\n            setSupportProgressBarIndeterminateVisibility(true);\r\n    \r\n            LoadMyTableTask loadMyTableTask = new LoadMyTableTask(new TableOperationCallback() {\r\n    \r\n                @Override\r\n                public void onTaskDone(Object... object) {\r\n    \r\n                    Table myTable = (Table) object[0];\r\n    \r\n                    if (myTable != null)\r\n                        ComparteMesaApplication.setMyTable(myTable);\r\n    \r\n                    FragmentManager fragmentManager = getSupportFragmentManager();\r\n                    fragmentManager.beginTransaction()\r\n                            .replace(R.id.content_frame, new TableFragment())\r\n                            .commit();\r\n    \r\n                    tituloSeccion = getTitle();\r\n                    getSupportActionBar().setTitle(tituloSeccion);\r\n                    setSupportProgressBarIndeterminateVisibility(false);\r\n    \r\n                }\r\n            });\r\n            loadMyTableTask.execute();\r\n        }\r\n```\r\n\r\n#### onResume() y onPause()\r\n\r\nUsamos `onPause()` para guardar las preferencias y `onResume` para recargar el fragmento principal `TableFragment`.\r\n\r\n```java\r\n\t@Override\r\n    public void onResume() {\r\n        super.onResume();\r\n\r\n        loadFragmentTable();\r\n    }\r\n```\r\n\r\n```java\r\n    @Override\r\n    public void onPause() {\r\n        super.onPause();\r\n\r\n        // Guardo las preferencias en los estados de pausa\r\n\r\n        String myUUID = ComparteMesaApplication.getMyUUID();\r\n\r\n        if (myUUID != null) {\r\n            int mode = Activity.MODE_PRIVATE;\r\n            SharedPreferences pref = getSharedPreferences(\"prefs\", mode);\r\n            SharedPreferences.Editor editor = pref.edit();\r\n            editor.putString(\"myUUID\", myUUID);\r\n            editor.commit();\r\n            Log.d(\"PREFS\", \"Guardada UUID: \" + myUUID);\r\n        }\r\n    }\r\n```\r\n\r\n#### getTables()\r\n\r\nDisponemos de una función que usará el fragmento `SearchFragment` para obtener las mesas una vez recibidas del servidor.\r\n\r\n```java\r\n   public List<Table> getTables() {\r\n        return tables;\r\n    }\r\n```\r\n\r\n## Conclusión\r\n\r\nSe puede decir que la aplicación aún tiene mucho que avanzar, ya que ahora mismo no es funcional. Sin embargo, ha sido un muy buen comienzo para aprender las bases de programación de Android y en un futuro cercano llegar a mejorarla lo suficiente como para poder subirla a Google Play.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}